# python中生成器和列表推导式的说明与优劣
**一.概念**

**1. 列表推导式是一种python风格的明显体现,这种写法不仅高效而且简短.**

> 使用列表推导式获取"下标":

	>>>{key:value for key,value in enumerate(["one", "two","three"])}
	{0: 'one', 1: 'two', 2: 'three'}
> 	反之想让列表获取"下标":

	>>>lst = ["one", "two","three"]
	>>>i = 0
	>>>for v in lst:
		   lst[i] = "%d:%s" % (i,lst[i])
		   i += 1
	>>>lst
	[0: 'one', 1: 'two', 2: 'three']
**2.生成器(generator)**

**生成器时一种特殊的迭代器**

*(1).什么时候需要使用生成器*

一般情况下我们不需要使用生成器,只有当我们因为性能限制才需要用到,比如我们使用python读取一个10g的文件,如果一次性将10g的文件加载到内存处理的话(read方法),内存肯定会溢出;这里如果可以使用生成器把读写交叉处理进行,比如使用(readline和readlines)就可以再循环读取的同时不断处理,这样就可以节省大量的内存空间.

*(2)生成生成器的两种方法*

> 第一种直接将列表推导式[]改为()即可
	
	i = (x for x in range(10))
> 第二种就是在函数中加入"yield"关键字;yield和return类似,都可以用来返回值,不同之处在于yield遇见next()就返回,再次执行时从上次返回的yield语句处继续执行.

**二.两者的差异**

(1)

列表推导式时将多有的值一次性加载到内存中;

生成器则不会将所有的值一次加载,而是延迟计算,一次返回一个结果,它不会一次生成所有结果,这样对大量数据的处理十分有用

	>>>import sys
	>>>i = [x for x in range(10000)]
	>>>j = (x for x in range(10000))
	>>>sys.getsizeof(i)
	87624
	>>>sys.getsizeof(j)
	88
> 显而易见,列表推导式占用很多的内存,而生成器几乎没什么占用内存

(2)

列表推导式可以遍历任意次

**生成器只能遍历一次**
> 这里需要理解一下迭代器的工作原理:迭代器是属于一个临时区,会安排一些元素进去,但是只有使用的时候才会创建易一些临时区,一旦遍历结束则临时区清空,再便利的话就失效了,这也正说明迭代器和生成器能够减少内存的开销
