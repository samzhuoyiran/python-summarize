GIL全局解释器锁



作用：保证同一时刻只有一个线程能使用到杯子
解释：当我们使用多线程的时候，在一个进程中只有一个GIL锁，那么这多个线程中谁拿到GIL谁就可以
使用CPU（PS：多个进程有多个吉尔锁）


问题1：什么时候会释放吉尔锁，
答：1遇到像i / o操作这种会有时间空闲情况造成cpu闲置的情况会释放Gil
	  2会有一个专门ticks进行计数一旦ticks数值达到100这个时候释放Gil lock线程之间开始竞争Gil lock（说明：
		蜱这个数值可以进行设置来延长或者缩减获得吉尔锁的线程使用CPU的时间）
		
问题2：互斥锁和Gil Lock的关系
	
	Gil Lock：保证同一时刻只有一个线程能使用到杯子
	互斥锁：多线程时，保证修改共享数据时有序的修改，不会产生数据修改混乱
	
	
	首先假设只有一个进程，这个进程中有两个线程Thread1，Thread2，要修改共享的数据，并且有互颠锁
	
	执行以下步骤
	
	（1）多线程运行，假设Thread1获得GIL可以使用cpu，这时Thread1获得互斥锁lock，Thread1可以改日期数据（但并
	没有开始修改数据）
	
	（2）Thread1线程在修改日期数据前发生了I / O操作或者ticks计数满100（注意就是没有运行到修改data data），这个
	时候Thread1让出了Gil，Gil Lock可以被竞争
	
	（3）Thread1和Thread2开始竞争Gil（注意：如果Thread1是因为i / o阻塞让出的Gil Thread2必定拿到Gil，如果
	Thread1是因为ticks计数满100让出Gil这个时候Thread1和Thread2公平竞争）
	
	（4）假设Thread2正确获得了GIL，运行代码去修改共享数据日期，由于Thread1有互斥锁lock，所以Thread2无法更改共享数据
	日期，这时Thread2让出Gillock，GIL锁再次发生竞争 
	
	
	（5）假设线程1又抢到GIL，由于其有互斥锁锁所以其可以继续修改共享数据的数据，当线程1修改完数据释放互斥锁锁，
	线程2在获得GIL与锁定后才可对数据进行修改
	
	以上描述了互斥锁和Gil Lock的一个关系
